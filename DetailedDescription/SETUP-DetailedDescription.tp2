BACKUP ~DetailedDescription/backup~
AUTHOR ~shohy@126.com~
VERSION ~v1.3~

ALWAYS

INCLUDE ~DetailedDescription/lib/desfunctions.tpa~

END

LANGUAGE  ~Simplified Chinese~	~schinese~ 		~DetailedDescription/tra/SY#GARBL.tra~

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BEGIN ~检查整个游戏的中文乱码条目并进行修复（可以不装。主要用于集成多MOD以及安装旧MOD后的编码修正）

（若未安装此组件，后继组件遇到乱码文本仅能将其弃用）

（如果运行时发现乱码文本并进行了修复，之后【务必】按q退出此窗口以便于文本更新。然后重新运行安装程序，再跳过此组件进行后继安装）~
DESIGNATED 0
REQUIRE_PREDICATE GAME_IS ~bgee bg2ee eet~ ~仅支持EE版~

COPY ~DetailedDescription/tra/SY#GARBL.tra~ ~override~

ACTION_CLEAR_ARRAY garbled_string

OUTER_SET garbledtext1exist = 0	//整个tlk文件里有没有ANSI编码
OUTER_SET garbledtext2exist = 0	//整个tlk文件里有没有棍斤拷

COPY ~lang/zh_CN/dialog.tlk~ ~override~		
	READ_LONG 0x0a totaltextamount

	SET textprogress = totaltextamount / 20
	
	PATCH_PRINT ~dialog.tlk共含%totaltextamount%条文本~

	FOR (tlkindex = 1 ; tlkindex < totaltextamount ; ++tlkindex) BEGIN	//遍历所有文本条目
	
		PATCH_IF (tlkindex MODULO textprogress == 0) BEGIN
			PATCH_PRINT ~完成进度%tlkindex%/%totaltextamount%~
		END

		SET descoffsetaddress = 0x24 + (%tlkindex% * 0x1a)	//计算出此条文本在tlk中记录开始位置的地址
		SET desclengthaddress = 0x28 + (%tlkindex% * 0x1a)	//计算出此条文本在tlk中记录文本长度的地址
		//PATCH_PRINT ~descoffsetaddress=%descoffsetaddress%~
		//PATCH_PRINT ~desclengthaddress=%desclengthaddress%~

		READ_LONG 0x0e textoffset	//tlk中总文本开始地址

		READ_LONG descoffsetaddress descoffset		//读取tlk索引，找到此条文本开始位置（需要加上总文本开始地址）
		//PATCH_PRINT ~descoffset=%descoffset%~
		READ_LONG desclengthaddress desclength		//读取tlk索引，找到此条文本长度（单位为单字节即FF）
		//PATCH_PRINT ~desclength=%desclength%~
		
		SET notgarbled = 1	//变成0表示当前循环有ANSI编码

		FOR (index = 0 ; index < desclength ; ++index) BEGIN	//对当前文本条目逐字节检查是不是UTF8编码
		
			SET textcodecheck = 0	//变成1表示是UTF8编码
			
			//PATCH_PRINT ~index=%index%~
			SET descaddress = descoffset + textoffset + index
			//LPF TO_HEX_NUMBER INT_VAR value = descaddress prefix = 1 RET hexNumber END
			//PATCH_PRINT ~descaddress=%hexNumber%~
			READ_BYTE descaddress textcode
			//LPF TO_HEX_NUMBER INT_VAR value = textcode prefix = 1 RET hexNumber END
			//PATCH_PRINT ~textcode=%hexNumber%~
					
			//SET $textcodecheck(~%index%~) = 0
			
			PATCH_IF textcode <= 0x7F BEGIN
				//PATCH_PRINT ~以UTF8编码规则检查，貌似是英文文本~
				SET textcodecheck = 1
				//SET $textcodecheck(~%index%~) = 1
			END
			
			SET codetest1 = textcode & 0b11100000
			//PATCH_PRINT ~codetest1=%codetest1%~
			SET codetest2 = textcode & 0b11110000
			//PATCH_PRINT ~codetest2=%codetest2%~
			SET codetest3 = textcode & 0b11111000
			//PATCH_PRINT ~codetest3=%codetest3%~
			
			PATCH_IF (codetest1 == 192) BEGIN	//高位三个bit是110，读下一个字节
				//PATCH_PRINT ~发现疑似二字节汉字开头~
				SET index = index +1
				SET descaddress = descoffset + textoffset + index
				//LPF TO_HEX_NUMBER INT_VAR value = descaddress prefix = 1 RET hexNumber END
				READ_BYTE descaddress textcode1
				//PATCH_PRINT ~发现疑似双字节汉字开头，读取下一字节textcode=%hexNumber%~
				SET codetest = textcode1 & 0b11000000
				PATCH_IF codetest == 128 BEGIN
					//PATCH_PRINT ~以UTF8编码规则检查，貌似是双字节汉字~
					SET textcodecheck = 1
					//SET indexo = index -1
					//SET $textcodecheck(~%indexo%~) = 1
				END
			END
			
			PATCH_IF (codetest2 == 224) BEGIN	//高位四个bit是1110，读下一个字节
				//PATCH_PRINT ~发现疑似三字节汉字开头~
				SET index = index +1
				SET descaddress = descoffset + textoffset + index
				//LPF TO_HEX_NUMBER INT_VAR value = descaddress prefix = 1 RET hexNumber END
				READ_BYTE descaddress textcode1
				//PATCH_PRINT ~发现疑似三字节汉字开头，读取下一字节textcode=%hexNumber%~
				SET codetest = textcode1 & 0b11000000
				PATCH_IF codetest == 128 BEGIN
					SET index = index +1
					SET descaddress = descoffset + textoffset + index
					//LPF TO_HEX_NUMBER INT_VAR value = descaddress prefix = 1 RET hexNumber END
					READ_BYTE descaddress textcode2
					//PATCH_PRINT ~读取下二字节textcode=%hexNumber%~
					SET codetest = textcode2 & 0b11000000
					PATCH_IF codetest == 128 BEGIN
						//PATCH_PRINT ~以UTF8编码规则检查，貌似是三字节汉字~
						SET textcodecheck = 1
						//SET indexo = index -2
						//SET $textcodecheck(~%indexo%~) = 1
					END
				END
			END
			
			PATCH_IF (codetest3 == 240) BEGIN	//高位四个bit是1110，读下一个字节
				//PATCH_PRINT ~发现疑似四字节汉字开头~
				SET index = index +1
				SET descaddress = descoffset + textoffset + index
				//LPF TO_HEX_NUMBER INT_VAR value = descaddress prefix = 1 RET hexNumber END
				READ_BYTE descaddress textcode1
				//PATCH_PRINT ~发现疑似四字节汉字开头，读取下一字节textcode=%hexNumber%~
				SET codetest = textcode1 & 0b11000000
				PATCH_IF codetest == 128 BEGIN
					SET index = index +1
					SET descaddress = descoffset + textoffset + index
					//LPF TO_HEX_NUMBER INT_VAR value = descaddress prefix = 1 RET hexNumber END
					READ_BYTE descaddress textcode2
					//PATCH_PRINT ~读取下二字节textcode=%hexNumber%~
					SET codetest = textcode2 & 0b11000000
					PATCH_IF codetest == 128 BEGIN			
						SET index = index +1
						SET descaddress = descoffset + textoffset + index
						//LPF TO_HEX_NUMBER INT_VAR value = descaddress prefix = 1 RET hexNumber END
						READ_BYTE descaddress textcode3
						//PATCH_PRINT ~读取下三字节textcode=%hexNumber%~
						SET codetest = textcode3 & 0b11000000
						PATCH_IF codetest == 128 BEGIN
							//PATCH_PRINT ~以UTF8编码规则检查，貌似是四字节汉字~
							SET textcodecheck = 1
							//SET indexo = index -3
							//SET $textcodecheck(~%indexo%~) = 1
						END
					END
				END
			END

			SET notgarbled = textcodecheck && notgarbled	//只要有一个textcodecheck是0即存在ANSI编码，则notgarbled为0
			PATCH_IF notgarbled == 0 BEGIN
				SET $garbled_string("%tlkindex%") = 0
				PATCH_PRINT ~编号%tlkindex%文本疑似乱码！可能引起游戏崩溃。该文本可修复，已记录~
				SET garbledtext1exist = 1
				SET index = desclength + 1	//提前结束本条文本检测
				INNER_ACTION BEGIN	//读取本条文本内容，写入ANSI编码的SY#GARBL.tra
					ACTION_GET_STRREF tlkindex tlkstrref
					APPEND "SY#GARBL.tra" "@%tlkindex% = ~~~~~%tlkstrref%  ~~~~~"
				END
			END
			
		END	//对当前文本条目逐字节检查是不是UTF8编码
		
		PATCH_IF notgarbled == 1 BEGIN		//前面检查都是UTF8编码，再检查是不是锟斤拷
			FOR (index = 0 ; index < desclength ; ++index) BEGIN
				SET descaddress = descoffset + textoffset + index
				READ_BYTE descaddress textcode
				PATCH_IF textcode == 239 BEGIN
					SET index = index +1
					SET descaddress = descoffset + textoffset + index
					READ_BYTE descaddress textcode1
					PATCH_IF textcode1 == 191 BEGIN
						SET index = index +1
						SET descaddress = descoffset + textoffset + index
						READ_BYTE descaddress textcode2
						PATCH_IF textcode2 == 189 BEGIN
							PATCH_PRINT ~编号%tlkindex%文本疑似乱码！但不会引起游戏崩溃。该文本无法修复，需自行检查文本来源~
							SET garbledtext2exist = 1
							SET index = desclength + 1	//提前结束本条文本检测
						END
					END
				END
			END
		END	//检查是不是锟斤拷
		
	END	//遍历tlk所有条目

	PATCH_IF garbledtext1exist == 0 && garbledtext2exist == 0 BEGIN
		PATCH_PRINT ~dialog.tlk已经检查完毕，未发现乱码情况，可以继续安装。~
	END
	PATCH_IF garbledtext2exist == 1 BEGIN
		PATCH_PRINT ~dialog.tlk已经检查完毕，发现存在无法修复的乱码情况，但不会引起游戏崩溃，跳过~
	END
	
BUT_ONLY

MOVE ~override/SY#GARBL.tra~ ~DetailedDescription/tra/schinese/SY#GARBL.tra~

OUTER_SET howtodotlk = 0

ACTION_IF garbledtext1exist == 1 BEGIN
	PRINT ~dialog.tlk已经检查完毕，发现可能引起游戏崩溃的乱码情况，是否尝试修复？
	
	输入1进行修复，输入2跳过继续安装下一个组件。
	
注：若修复失败，或修复后仍有乱码，可能是因为存在乱码+非乱码文字混合的情况，或是存在中/英文以外的语言。~
	
	ACTION_READLN howtodotlk
	OUTER_WHILE NOT(IS_AN_INT %howtodotlk%) || (%howtodotlk% > 2) || (%howtodotlk% < 1) BEGIN
		PRINT ~输入1进行修复，输入2跳过继续安装下一个组件。~
		ACTION_READLN  howtodotlk
	END

	ACTION_IF howtodotlk == 1 BEGIN
		PRINT ~尝试修复中……~
		LAF HANDLE_CHARSETS
			INT_VAR
				infer_charsets = 1
			STR_VAR
				tra_path = ~DetailedDescription/tra~
				out_path = ~DetailedDescription/tra/utf8~
				iconv_path = ~DetailedDescription/iconv~
		END
		LOAD_TRA ~DetailedDescription/tra/utf8/schinese/SY#GARBL.tra~
		//INNER_ACTION BEGIN COPY ~DetailedDescription/2da/SY#GARBL.2da~ ~override~ END
		ACTION_PHP_EACH garbled_string AS tlkindex => 0 BEGIN
			OUTER_SPRINT tlkstringref ( AT "%tlkindex%" )
			OUTER_INNER_PATCH_SAVE tlkstringref ~%tlkstringref%~ BEGIN	//去除最后的空格
				REPLACE_TEXTUALLY ~ +$~ ~~
			END
			PRINT ~条目%tlkindex%修复为：%tlkstringref%~
			STRING_SET_EVALUATE tlkindex ~%tlkstringref%~
			//APPEND ~DetailedDescription/2da/SY#GARBL.2da~ ~%tlkindex%~
		END
		PRINT ~修复完毕。【务必】按q退出此窗口以便于文本更新，然后重新运行安装程序，再跳过此组件进行后继安装【务必】。

（若发现修复文本后仍为乱码，可能因为原文是乱码和非乱码混合，需要手动处理）~
	END

	ACTION_IF howtodotlk == 2 BEGIN
		PRINT ~跳过修复操作。乱码文本及其条目编号已存放在“DetailedDescription/tra/schinese/SY#GARBL.tra”，可自行查看处理。~
	END
	
END

ACTION_IF howtodotlk == 1 BEGIN
//不保险再来一次
	LOAD_TRA ~DetailedDescription/tra/utf8/schinese/SY#GARBL.tra~

	ACTION_PHP_EACH garbled_string AS tlkindex => 0 BEGIN
		OUTER_SPRINT tlkstringref ( AT "%tlkindex%" )
		OUTER_PATCH_SAVE tlkstringref ~%tlkstringref%~ BEGIN	//修改文本
			REPLACE_TEXTUALLY ~ +~ ~~
		END
		STRING_SET_EVALUATE tlkindex ~%tlkstringref%~
	END
END

ACTION_IF FILE_EXISTS ~override/SY#GARBL.tra~ BEGIN
	DELETE ~override/SY#GARBL.tra~
END



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BEGIN ~显示所有细节~
SUBCOMPONENT ~物品增加详细说明~

OUTER_SET detailed_desc = 1

INCLUDE ~DetailedDescription/lib/handleitem.tpa~


BEGIN ~忽略一些繁琐的细节（如移除特定法术、设置状态等）~
SUBCOMPONENT ~物品增加详细说明~

OUTER_SET detailed_desc = 0

INCLUDE ~DetailedDescription/lib/handleitem.tpa~

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BEGIN ~仅处理已注册法术（例如法术书和部分原版特殊技能）并显示所有细节~
SUBCOMPONENT ~法术增加详细说明（随等级成长的法术只显示最低级和最高级的效果）~

OUTER_SET detailed_desc = 1

INCLUDE ~DetailedDescription/lib/handlespella.tpa~


BEGIN ~仅处理已注册法术，忽略一些繁琐的细节（如移除特定法术、设置状态等）~
SUBCOMPONENT ~法术增加详细说明（随等级成长的法术只显示最低级和最高级的效果）~

OUTER_SET detailed_desc = 0

INCLUDE ~DetailedDescription/lib/handlespella.tpa~


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
BEGIN ~处理所有法术，并显示所有细节~
SUBCOMPONENT ~法术增加详细说明（随等级成长的法术只显示最低级和最高级的效果）~

OUTER_SET detailed_desc = 1

INCLUDE ~DetailedDescription/lib/handlespellb.tpa~



BEGIN ~处理所有法术，忽略细节~
SUBCOMPONENT ~法术增加详细说明（随等级成长的法术只显示最低级和最高级的效果）~

OUTER_SET detailed_desc = 0

INCLUDE ~DetailedDescription/lib/handlespellb.tpa~